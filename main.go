package main

import (
	"encoding/json"
	"fmt"
	"log"
	"os"
	"strconv"
	"strings"
	"sync"
)

var (
	threads chan struct{}
	mu      sync.Mutex
	retries uint64 = 0
)

const max_retries uint64 = 5

func main() {

	f, err := os.Create(`results`)
	if err != nil {
		log.Fatal(err)
	}
	f.Close()

	threads_number, _ := strconv.Atoi(os.Getenv("THREADS_NUMBER"))
	threads = make(chan struct{}, threads_number)

	params := strings.Split(os.Getenv("REQUEST_PARAMS"), ";")

	sourceNodes := make(map[string]interface{})
	document_type := []string{`dataset`, `text`}
	for _, repo := range params {

		for year := 2010; year < 2022; year++ {

			for _, dtype := range document_type {

				for page := 1; page < 41; page++ {

					if retries > max_retries {
						retries = 0
						break
					}

					threads <- struct{}{}
					ctx, cancel := InitDriver()
					nodes_instance := NewNodes()
					go nodes_instance.Execute(
						repo+`?resource-type-id=`+dtype+`&registered=`+fmt.Sprintf("%d", year)+`&page=`+fmt.Sprintf("%d", page),
						`a#title-link`,
						ctx,
						cancel,
						`href`,
						&sourceNodes,
					)
				}

			}

		}

	}

	for {
		if len(threads) == 0 {
			retries = 0
			break
		}
	}

	ShuffleSlice(sourceNodes[`NodesValue`].([]string))
	chunked := ChunkSlice(sourceNodes[`NodesValue`], 4)

	for _, i := range chunked.([][]string) {
		var sourcePage []string
		for _, v := range i {
			threads <- struct{}{}
			page_instance := NewPage(`PageFromDriver`)
			ctx, cancel := InitDriver()
			go page_instance.Execute(
				`https://search.datacite.org`+v,
				ctx,
				cancel,
				&sourcePage,
			)
		}

		for {
			if len(threads) == 0 {
				retries = 0
				break
			}
		}

		var sourceSoup []string
		for _, v := range sourcePage {
			threads <- struct{}{}
			soup_instance := NewSoup()
			go soup_instance.Execute(
				v,
				[]string{`script`, `type`, `application/ld+json`},
				&sourceSoup,
			)
		}

		for {
			if len(threads) == 0 {
				retries = 0
				break
			}
		}

		for _, i := range sourceSoup {

			auto := &AutoGenerated{}
			json.Unmarshal([]byte(i), &auto)

			detail := Detail{}
			detail.URL = auto.URL
			detail.Title = auto.Name
			detail.Describe = auto.Description
			info := Info{}
			info.Publisher = auto.Publisher.Name
			info.Created = auto.DatePublished
			info.Identifier = auto.ID
			info.Language = auto.InLanguage
			detail.Info = info

			if detail.URL == "" && detail.Title == "" {
				continue
			}

			json_res, _ := json.Marshal(&detail)

			WriteFile(`results`, json_res)
		}

	}

	for {
		if len(threads) == 0 {
			retries = 0
			break
		}
	}

	upload_instance := NewUpload()
	upload_instance.Execute(`results`, os.Getenv(`INFO`))

}
